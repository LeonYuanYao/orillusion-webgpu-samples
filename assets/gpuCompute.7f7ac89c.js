import"./modulepreload-polyfill.b7f2da20.js";import{c as m,m as U}from"./mat4.f7fc816f.js";var G=`@group(0) @binding(0) var<storage, read> modelView: array<mat4x4<f32>>;
@group(0) @binding(1) var<storage, read> projection : mat4x4<f32>;
@group(0) @binding(2) var<storage, read_write> mvp : array<mat4x4<f32>>;
@group(0) @binding(3) var<uniform> count : u32;

@stage(compute) @workgroup_size(128)
fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
    // Guard against out-of-bounds work group sizes
    let index = global_id.x;
    if (index >= count) {
        return;
    }

    mvp[index] = projection * modelView[index];
}`;async function S(){if(!navigator.gpu)throw new Error("Not Support WebGPU");const e=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});if(!e)throw new Error("No Adapter Found");return await e.requestDevice({requiredLimits:{maxStorageBufferBindingSize:e.limits.maxStorageBufferBindingSize}})}async function x(e,n,a){const s={layout:"auto",compute:{module:e.createShaderModule({code:G}),entryPoint:"main"}},o=await e.createComputePipelineAsync(s),p=e.createBuffer({size:n.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});console.time("writeBuffer"),e.queue.writeBuffer(p,0,n),console.timeEnd("writeBuffer");const l=e.createBuffer({size:a.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});e.queue.writeBuffer(l,0,a);const g=e.createBuffer({size:n.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),i=e.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});e.queue.writeBuffer(i,0,new Uint32Array([u]));const f=e.createBindGroup({layout:o.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:p}},{binding:1,resource:{buffer:l}},{binding:2,resource:{buffer:g}},{binding:3,resource:{buffer:i}}]});return{pipeline:o,bindGroup:f,mvpBuffer:g}}async function y(){B.innerHTML=b.innerHTML="-",c.innerHTML="Testing ...",c.disabled=!0,await new Promise(r=>setTimeout(r));const e=new Float32Array(u*4*4),n=[],a=m();for(let r=0;r<u;r++){const t=m();n.push(t),e.set(t,r*4*4)}console.time("cpu multiply x10");let s=performance.now();for(let r=0;r<10;r++)for(let t=0;t<u;t++){let d=n[t];U(d,a,d)}B.innerHTML=((performance.now()-s)/10).toFixed(2),console.timeEnd("cpu multiply x10");const o=await S(),{pipeline:p,bindGroup:l,mvpBuffer:g}=await x(o,e,a),i=o.createBuffer({size:e.byteLength,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),f=o.createCommandEncoder();for(let r=0;r<300;r++){const t=f.beginComputePass();t.setPipeline(p),t.setBindGroup(0,l),t.dispatchWorkgroups(Math.ceil(u/128)),t.end()}f.copyBufferToBuffer(g,0,i,0,e.byteLength),o.queue.submit([f.finish()]),console.time("gpu multiply x300"),s=performance.now(),await i.mapAsync(GPUMapMode.READ),b.innerHTML=((performance.now()-s)/300).toFixed(2),console.timeEnd("gpu multiply x300");const w=i.getMappedRange(),P=new Float32Array(w);console.log(P),i.unmap(),c.disabled=!1,c.innerHTML="Run"}let u=1e6,T=document.querySelector("#select"),c=document.querySelector("button"),B=document.querySelector("#cpu"),b=document.querySelector("#gpu");T.addEventListener("change",e=>{console.log(e.target.value),u=+e.target.value,y()});c.addEventListener("click",y);
